// ============================================
// MERN-AUTH-LIB - Complete Package Structure
// ============================================

// package.json (Root)
{
  "name": "mern-auth-lib",
  "version": "1.0.0",
  "description": "One-line MERN authentication library for students",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["mern", "auth", "authentication", "react", "express", "mongodb"],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.5.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "zod": "^3.22.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.5.0"
  },
  "peerDependencies": {
    "react": ">=16.8.0",
    "react-dom": ">=16.8.0"
  }
}

// =============================================
// BACKEND COMPONENTS
// =============================================

// backend/index.js - Main Backend Export
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const authRoutes = require('./routes/auth');
const authMiddleware = require('./middleware/auth');

const createAuthBackend = (config = {}) => {
  const {
    mongoUri = process.env.MONGO_URI || 'mongodb://localhost:27017/mern-auth',
    jwtSecret = process.env.JWT_SECRET || 'your-secret-key-change-in-production',
    corsOrigin = process.env.CORS_ORIGIN || 'http://localhost:3000',
    cookieMaxAge = 7 * 24 * 60 * 60 * 1000 // 7 days
  } = config;

  // Connect to MongoDB
  mongoose.connect(mongoUri)
    .then(() => console.log('✅ MongoDB connected successfully'))
    .catch(err => console.error('❌ MongoDB connection error:', err));

  const app = express();

  // Middleware
  app.use(cors({
    origin: corsOrigin,
    credentials: true
  }));
  app.use(express.json());
  app.use(cookieParser());

  // Make config available to routes
  app.locals.authConfig = {
    jwtSecret,
    cookieMaxAge
  };

  // Auth routes
  app.use('/api/auth', authRoutes);

  // Protected route example
  app.get('/api/protected', authMiddleware, (req, res) => {
    res.json({
      success: true,
      message: 'Protected route accessed successfully',
      user: req.user
    });
  });

  return app;
};

module.exports = { createAuthBackend, authMiddleware };

// =============================================
// backend/models/User.js - User Model
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Username is required'],
    unique: true,
    trim: true,
    minlength: [3, 'Username must be at least 3 characters'],
    maxlength: [20, 'Username must be less than 20 characters']
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [6, 'Password must be at least 6 characters']
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(12);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// Remove password from JSON output
userSchema.methods.toJSON = function() {
  const user = this.toObject();
  delete user.password;
  return user;
};

module.exports = mongoose.model('User', userSchema);

// =============================================
// backend/routes/auth.js - Authentication Routes
const express = require('express');
const jwt = require('jsonwebtoken');
const { z } = require('zod');
const User = require('../models/User');
const authMiddleware = require('../middleware/auth');

const router = express.Router();

// Validation schemas
const signupSchema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be less than 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),
  email: z.string()
    .email('Please enter a valid email address'),
  password: z.string()
    .min(6, 'Password must be at least 6 characters')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain at least one uppercase letter, one lowercase letter, and one number'),
  confirmPassword: z.string()
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});

const signinSchema = z.object({
  email: z.string().email('Please enter a valid email address'),
  password: z.string().min(1, 'Password is required')
});

// Generate JWT token
const generateToken = (userId, jwtSecret) => {
  return jwt.sign({ userId }, jwtSecret, { expiresIn: '7d' });
};

// Sign up route
router.post('/signup', async (req, res) => {
  try {
    const { jwtSecret, cookieMaxAge } = req.app.locals.authConfig;
    
    // Validate request body
    const validatedData = signupSchema.parse(req.body);
    const { username, email, password } = validatedData;

    // Check if user already exists
    const existingUser = await User.findOne({
      $or: [{ email }, { username }]
    });

    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: existingUser.email === email ? 'Email already registered' : 'Username already taken'
      });
    }

    // Create new user
    const user = new User({ username, email, password });
    await user.save();

    // Generate token
    const token = generateToken(user._id, jwtSecret);

    // Set HTTP-only cookie
    res.cookie('authToken', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: cookieMaxAge
    });

    res.status(201).json({
      success: true,
      message: 'User created successfully',
      user: {
        _id: user._id,
        username: user.username,
        email: user.email
      }
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: error.errors.map(err => ({
          field: err.path[0],
          message: err.message
        }))
      });
    }

    console.error('Signup error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// Sign in route
router.post('/signin', async (req, res) => {
  try {
    const { jwtSecret, cookieMaxAge } = req.app.locals.authConfig;
    
    // Validate request body
    const validatedData = signinSchema.parse(req.body);
    const { email, password } = validatedData;

    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }

    // Check password
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }

    // Generate token
    const token = generateToken(user._id, jwtSecret);

    // Set HTTP-only cookie
    res.cookie('authToken', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: cookieMaxAge
    });

    res.json({
      success: true,
      message: 'Sign in successful',
      user: {
        _id: user._id,
        username: user.username,
        email: user.email
      }
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: error.errors.map(err => ({
          field: err.path[0],
          message: err.message
        }))
      });
    }

    console.error('Signin error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// Sign out route
router.post('/signout', (req, res) => {
  res.clearCookie('authToken');
  res.json({
    success: true,
    message: 'Signed out successfully'
  });
});

// Get current user route
router.get('/me', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    res.json({
      success: true,
      user: {
        _id: user._id,
        username: user.username,
        email: user.email
      }
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

module.exports = router;

// =============================================
// backend/middleware/auth.js - Auth Middleware
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
  try {
    const { jwtSecret } = req.app.locals.authConfig;
    const token = req.cookies.authToken;

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Access denied. No token provided.'
      });
    }

    const decoded = jwt.verify(token, jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({
      success: false,
      message: 'Invalid token'
    });
  }
};

module.exports = authMiddleware;

// =============================================
// FRONTEND COMPONENTS
// =============================================

// frontend/index.js - Main Frontend Export
import React from 'react';
import AuthProvider from './context/AuthContext';
import AuthForm from './components/AuthForm';
import useAuth from './hooks/useAuth';

// Main export for easy import
export { AuthProvider, AuthForm, useAuth };

// Default export for single import
export default {
  AuthProvider,
  AuthForm,
  useAuth
};

// =============================================
// frontend/context/AuthContext.js - Auth Context
import React, { createContext, useState, useEffect } from 'react';
import axios from 'axios';

const AuthContext = createContext();

// Configure axios defaults
axios.defaults.withCredentials = true;

const AuthProvider = ({ children, apiUrl = 'http://localhost:5000/api/auth' }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Create axios instance with base URL
  const authAPI = axios.create({
    baseURL: apiUrl,
    withCredentials: true
  });

  // Check if user is authenticated on mount
  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const response = await authAPI.get('/me');
      if (response.data.success) {
        setUser(response.data.user);
        // Store user data in localStorage for easy access
        localStorage.setItem('user', JSON.stringify(response.data.user));
      }
    } catch (error) {
      console.log('Not authenticated');
      localStorage.removeItem('user');
    } finally {
      setLoading(false);
    }
  };

  const signup = async (userData) => {
    try {
      setError(null);
      const response = await authAPI.post('/signup', userData);
      
      if (response.data.success) {
        setUser(response.data.user);
        localStorage.setItem('user', JSON.stringify(response.data.user));
        return { success: true, message: response.data.message };
      }
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Signup failed';
      setError(errorMessage);
      return { 
        success: false, 
        message: errorMessage,
        errors: error.response?.data?.errors 
      };
    }
  };

  const signin = async (userData) => {
    try {
      setError(null);
      const response = await authAPI.post('/signin', userData);
      
      if (response.data.success) {
        setUser(response.data.user);
        localStorage.setItem('user', JSON.stringify(response.data.user));
        return { success: true, message: response.data.message };
      }
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Signin failed';
      setError(errorMessage);
      return { 
        success: false, 
        message: errorMessage,
        errors: error.response?.data?.errors 
      };
    }
  };

  const signout = async () => {
    try {
      await authAPI.post('/signout');
      setUser(null);
      localStorage.removeItem('user');
      return { success: true };
    } catch (error) {
      console.error('Signout error:', error);
      // Clear local state even if request fails
      setUser(null);
      localStorage.removeItem('user');
      return { success: false };
    }
  };

  const value = {
    user,
    loading,
    error,
    signup,
    signin,
    signout,
    checkAuth
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export { AuthContext };
export default AuthProvider;

// =============================================
// frontend/hooks/useAuth.js - Auth Hook
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

const useAuth = () => {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
};

export default useAuth;

// =============================================
// frontend/components/AuthForm.js - Auth Form Component
import React, { useState } from 'react';
import useAuth from '../hooks/useAuth';

const AuthForm = ({ 
  mode = 'signin', 
  design = 'modern', 
  onSuccess,
  onError,
  className = ''
}) => {
  const { signup, signin, loading } = useAuth();
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear specific error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};

    if (mode === 'signup') {
      if (!formData.username.trim()) {
        newErrors.username = 'Username is required';
      } else if (formData.username.length < 3) {
        newErrors.username = 'Username must be at least 3 characters';
      }
    }

    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    if (mode === 'signup') {
      if (!formData.confirmPassword) {
        newErrors.confirmPassword = 'Please confirm your password';
      } else if (formData.password !== formData.confirmPassword) {
        newErrors.confirmPassword = 'Passwords do not match';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) return;

    setIsSubmitting(true);
    
    try {
      const result = mode === 'signup' 
        ? await signup(formData)
        : await signin({ email: formData.email, password: formData.password });

      if (result.success) {
        if (onSuccess) onSuccess(result);
        // Clear form on success
        setFormData({
          username: '',
          email: '',
          password: '',
          confirmPassword: ''
        });
      } else {
        if (result.errors) {
          const fieldErrors = {};
          result.errors.forEach(error => {
            fieldErrors[error.field] = error.message;
          });
          setErrors(fieldErrors);
        }
        if (onError) onError(result);
      }
    } catch (error) {
      console.error('Form submission error:', error);
      if (onError) onError({ success: false, message: 'An unexpected error occurred' });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Design styles
  const getDesignStyles = () => {
    const baseStyles = {
      form: 'max-w-md mx-auto p-6 rounded-lg shadow-md',
      input: 'w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 mb-4',
      button: 'w-full py-2 px-4 rounded-md font-medium transition-colors',
      error: 'text-red-500 text-sm mt-1 mb-2'
    };

    const designs = {
      modern: {
        form: `${baseStyles.form} bg-white border border-gray-200`,
        input: `${baseStyles.input} border-gray-300 focus:ring-blue-500 focus:border-blue-500`,
        button: `${baseStyles.button} bg-blue-600 text-white hover:bg-blue-700 disabled:bg-blue-300`,
        error: baseStyles.error
      },
      minimal: {
        form: `${baseStyles.form} bg-gray-50`,
        input: `${baseStyles.input} border-gray-200 focus:ring-gray-400 focus:border-gray-400`,
        button: `${baseStyles.button} bg-gray-800 text-white hover:bg-gray-900 disabled:bg-gray-400`,
        error: baseStyles.error
      },
      colorful: {
        form: `${baseStyles.form} bg-gradient-to-br from-purple-50 to-pink-50 border border-purple-200`,
        input: `${baseStyles.input} border-purple-300 focus:ring-purple-500 focus:border-purple-500`,
        button: `${baseStyles.button} bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:from-purple-700 hover:to-pink-700 disabled:from-purple-300 disabled:to-pink-300`,
        error: baseStyles.error
      }
    };

    return designs[design] || designs.modern;
  };

  const styles = getDesignStyles();

  return (
    <form onSubmit={handleSubmit} className={`${styles.form} ${className}`}>
      <h2 className="text-2xl font-bold text-center mb-6">
        {mode === 'signup' ? 'Sign Up' : 'Sign In'}
      </h2>

      {mode === 'signup' && (
        <div>
          <input
            type="text"
            name="username"
            placeholder="Username"
            value={formData.username}
            onChange={handleChange}
            className={styles.input}
            disabled={isSubmitting}
          />
          {errors.username && <p className={styles.error}>{errors.username}</p>}
        </div>
      )}

      <div>
        <input
          type="email"
          name="email"
          placeholder="Email"
          value={formData.email}
          onChange={handleChange}
          className={styles.input}
          disabled={isSubmitting}
        />
        {errors.email && <p className={styles.error}>{errors.email}</p>}
      </div>

      <div>
        <input
          type="password"
          name="password"
          placeholder="Password"
          value={formData.password}
          onChange={handleChange}
          className={styles.input}
          disabled={isSubmitting}
        />
        {errors.password && <p className={styles.error}>{errors.password}</p>}
      </div>

      {mode === 'signup' && (
        <div>
          <input
            type="password"
            name="confirmPassword"
            placeholder="Confirm Password"
            value={formData.confirmPassword}
            onChange={handleChange}
            className={styles.input}
            disabled={isSubmitting}
          />
          {errors.confirmPassword && <p className={styles.error}>{errors.confirmPassword}</p>}
        </div>
      )}

      <button
        type="submit"
        disabled={isSubmitting || loading}
        className={styles.button}
      >
        {isSubmitting ? 'Please wait...' : (mode === 'signup' ? 'Sign Up' : 'Sign In')}
      </button>
    </form>
  );
};

export default AuthForm;

// =============================================
// USAGE EXAMPLES
// =============================================

/*
// Example 1: Backend Setup (server.js)
const express = require('express');
const { createAuthBackend } = require('mern-auth-lib');

const app = createAuthBackend({
  mongoUri: 'mongodb://localhost:27017/myapp',
  jwtSecret: 'your-super-secret-jwt-key',
  corsOrigin: 'http://localhost:3000'
});

app.listen(5000, () => {
  console.log('Server running on port 5000');
});

// Example 2: Frontend Setup (App.js)
import React from 'react';
import { AuthProvider, AuthForm, useAuth } from 'mern-auth-lib';

function Dashboard() {
  const { user, signout } = useAuth();
  
  return (
    <div>
      <h1>Welcome, {user.username}!</h1>
      <p>Email: {user.email}</p>
      <button onClick={signout}>Sign Out</button>
    </div>
  );
}

function App() {
  const { user } = useAuth();
  
  return (
    <div className="App">
      {user ? (
        <Dashboard />
      ) : (
        <AuthForm 
          mode="signin" 
          design="modern"
          onSuccess={(result) => console.log('Success:', result)}
          onError={(error) => console.error('Error:', error)}
        />
      )}
    </div>
  );
}

// Wrap your app with AuthProvider
export default function AppWrapper() {
  return (
    <AuthProvider apiUrl="http://localhost:5000/api/auth">
      <App />
    </AuthProvider>
  );
}

// Example 3: Quick Setup for Students
// Backend (server.js) - One line setup
const app = require('mern-auth-lib').createAuthBackend();
app.listen(5000);

// Frontend (App.js) - One line import + simple usage
import { AuthProvider, AuthForm } from 'mern-auth-lib';

function App() {
  return (
    <AuthProvider>
      <AuthForm mode="signup" design="colorful" />
    </AuthProvider>
  );
}
*/